---
title: Figures for CHI26 paper
format: 
  html:
    code-fold: true
    toc: true
  # revealjs:
  #   scrollable: true
  #   toc: true     # this adds a TOC slide at the beginning
execute:
  cache: true
  echo: true
---

```{r}
#| label: setup
#| include: false
#| echo: true
library(ggplot2)
library(tsibbledata)
library(dplyr)
library(lubridate)
library(tsibble)
library(ggtime)
library(patchwork)
theme_set(theme_minimal())

uad <- as_tsibble(USAccDeaths) |> 
  as_tibble() |> 
  mutate(index = as.Date(index))

bank_calls <- fpp3::bank_calls

pedestrian <- tsibble::pedestrian |>
  tsibble::fill_gaps() |>
  mutate(Date = as.Date(strftime(Date_Time, "%Y-%m-%d"))) |>
  arrange(Sensor, Date_Time)

# plot_save <- function(x, name = knitr::opts_current$get("label"), 12, 8) 
#   ggsave(
#     filename = fig <- paste0("../plots/", name, ".png"),
#     plot = x,
#     width = width,
#     height = height,
#     units = "cm",
#     dpi = 300
#   )
#   include_graphics(fig)
# }

knitr::knit_hooks$set(plot = function(x, options) {
  # x: the default plot file path (knitr saves the plot here)
  # options: chunk options, includes label, fig.num, etc.
  # We'll copy/sync the plot to "plots" using ggsave

  # Compute a name for the saved file
  label <- options$label
  fig.num <- options$fig.num %||% 1
  fig.cur <- options$fig.cur %||% 1
  fig.width <- options$fig.width %||% 12
  fig.height <- options$fig.height %||% 8
  ext <- tools::file_ext(x)
  # New filename, e.g. plots/my-label-1.png
  plot_file <- sprintf("../plots/plot-%s-%ix%i-%d.%s", label, fig.width, fig.height, fig.cur, ext)

  # Copy the image to the plots/ path
  file.copy(x, plot_file, overwrite = TRUE)
  
  # Now, continue as usual -- display the plot in the final document
  out <- knitr::hook_plot_md(x, options)

  sprintf('<a href="%s" download><span title="Click to download">%s</span></a>', plot_file, out)
})

# Fudge the data to correctly handle DST changes
# Since the data was provided in civil time, the 2AM counts before/after DST are combined.
pedestrian[53763, "Count"] <- 9
pedestrian[53764, "Count"] <- 5
```

## Timezones

![](chi26-figures/fig-wishlist-00.jpg)

Timezones are tricky to accurately represent in visualisations. In ggplot2, the `POSIXct` time class is plotted in absolute time, while the `Date` class is plotted in civil time (since `Date` lacks timezone information).

### >Daily timezone differences

When plotting daily/weekly/monthly/annual/... data in different timezones, the civil time of the day is the same regardless of the timezone. However, the absolute time of the day can be very different in different timezones.



```{r}
#| label: pedestrian-mel-lon-daily
MEL_LDN_mockdata <- pedestrian |> 
  filter(
    between(Date, ymd("2015-03-02"), ymd("2015-03-12")),
    Sensor %in% c("Bourke Street Mall (North)", "QV Market-Elizabeth St (West)")
  ) |> 
  index_by(Date) |>
  group_by(Sensor) |>
  summarise(Count = sum(Count)) |>
  mutate(
    Sensor = factor(Sensor, levels = c("Bourke Street Mall (North)", "QV Market-Elizabeth St (West)"), labels = c("Melbourne", "London")),
    Count = case_when(Sensor == "London" ~ Count*1.75, TRUE ~ Count),
  )
  
daily_civil <- MEL_LDN_mockdata |> 
  autoplot(Count) + 
  geom_point()
daily_absolute <- MEL_LDN_mockdata |>
  mutate(
    Date = force_tzs(
      as.POSIXct(Date), 
      tzones = case_match(Sensor, 
        "Melbourne" ~ "Australia/Melbourne", 
        "London" ~ "Europe/London"
      )
    )
  ) |> 
  autoplot(Count) + 
  geom_point()

daily_civil / daily_absolute
```

### Sub-daily DST changes in civil time

When plotting sub-daily data that crosses a daylight saving time (DST) boundary, the civil time can change by 1 hour while the absolute time remains unchanged. This can lead to misleading visualisations if not handled correctly.

```{r}
#| label: dst-shift
tz_shift <- as_tibble(tsibbledata::gafa_stock) |>
  filter(
    (Symbol == "AAPL" & Date <= "2014-01-15") | 
      (Symbol == "GOOG" & Date <= "2014-01-13")
  ) |>
  mutate(Date = Sys.Date() + hours(c(1:3, 3:9, 1:2, 4:9)), DST = ifelse(Symbol == "AAPL", "DST Ends", "DST Begins")) |> 
  slice(1:3, 3:12, 12:n()) |> 
  mutate(
    open = duplicated(Open),
    closed = c(open[-1], FALSE),
    Date = Date + open*3600*((DST=="DST Begins")*2-1)
  ) 

ggplot2_civil <- tz_shift |> 
  ggplot(aes(x = Date, y = Close)) + 
  geom_path(data = filter(tz_shift, !open)) +
  facet_wrap(vars(DST), ncol = 2, scales = "free_y") + 
  scale_shape_manual(values = c("TRUE" = 16, "FALSE" = 1)) + 
  guides(shape = "none")

ggtime_civil <- tz_shift |> 
  ggplot(aes(x = Date, y = Close)) + 
  geom_path(aes(group = cumsum(open))) + 
  geom_path(linetype = "dashed", data = filter(tz_shift, open | closed)) +
  facet_wrap(vars(DST), ncol = 2, scales = "free_y") + 
  scale_shape_manual(values = c("TRUE" = 16, "FALSE" = 1)) + 
  guides(shape = "none")

ggplot2_civil / ggtime_civil
```

### Timezones on pedestrian counts (from ggtime vignette)


Time series plotted with ggplot2 are typically shown in absolute time, but ggtime defaults to plotting in civil time (also known as local or clock time). Human activities are usually scheduled in local time, so seasonality and other calendar patterns are more evident in local time.

Timezones are usually only associated with `POSIXt` date-times, however timezones are also relevant `Date` dates and all other temporal granularities. Time series plotted with ggplot2 are shown in absolute time, however since `Date` types don't store timezone information, they are effectively plotted in civil time*.

The ggtime package instead defaults to plotting in civil time (also known as local or clock time). Human activities are usually scheduled in local time, so seasonality and other calendar patterns are more evident in local time. With mixtime, timezones can be specified with all temporal granularities (dates, yearmonth, ...), allowing for more precise positioning of time in different timezones.

|                  | ggplot2         | ggtime (default) `position_civil()` | ggtime `position_absolute()` |
|------------------|:---------------:|:-----------------:|:-----------------:|
| **POSIXt**       | Absolute        | Civil             | Absolute          |
| **Date**         | Civil*          | Civil             | Absolute          |
| **Other times**  | Not-supported   | Civil             | Absolute          |

<!-- DST -->

When plotting time series in civil time, changes in time zone (e.g., daylight saving time) are automatically handled by ggtime. Consider the number of pedestrians passing through Southern Cross Station (timezone Australia/Melbourne) in 2015. On April 5th at 3am, clocks were set back one hour to 2am (and so 2am-3am occurs twice in civil time). The clocks then moved forward again on October 4th at 2am, effectively skipping the hour from 2am-3am.

In ggplot2, the time values are shown in **absolute time** so that the spacing between points is consistently 1 hour apart.

```{r}
#| label: dst-ggplot2
#| fig-height: 4
pedestrian |>
  filter(
    Sensor == "Southern Cross Station",
    Date %in% as.Date(c("2015-04-05", "2015-10-04"))
  ) |>
  ggplot(aes(x = Date_Time, y = Count)) +
  geom_line() +
  geom_point() +
  facet_grid(
    cols = vars(Date),
    scales = "free_x",
    labeller = labeller(
      Date = c(
        "2015-04-05" = "2015-04-05\n(DST ends)",
        "2015-10-04" = "2015-10-04\n(DST begins)"
      )
    )
  ) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_rect(
    aes(xmin = xmin, xmax = xmax),
    ymin = -Inf,
    ymax = Inf,
    fill = "grey20",
    alpha = 0.2,
    data = data.frame(
      Date_Time = as.POSIXct(NA),
      Count = Inf,
      xmin = as.POSIXct(
        c("2015-04-05 01:59.999", "2015-10-04 02:00"),
        tz = "Australia/Melbourne"
      ),
      xmax = as.POSIXct(
        c("2015-04-05 03:00", "2015-10-04 04:00"),
        tz = "Australia/Melbourne"
      ),
      Date = as.Date(c("2015-04-05", "2015-10-04"))
    )
  ) + 
  labs(x = "Absolute time (Australia/Melbourne)")
```

<!-- TODO: Iterate on the shaded region with CH to make it clearer -->

In ggtime, the time values are shown in **civil time** so that the 2am-3am hour occurs twice in April, and is skipped in October.

```{r}
#| label: dst-civil
#| fig-height: 4
pedestrian |>
  filter(
    Sensor == "Southern Cross Station",
    Date %in% as.Date(c("2015-04-05", "2015-10-04"))
  ) |>
  ggplot(aes(x = Date_Time, y = Count)) +
  geom_time_line() +
  geom_point(position = position_time_civil()) +
  facet_grid(
    cols = vars(Date),
    scales = "free_x",
    labeller = labeller(
      Date = c(
        "2015-04-05" = "2015-04-05\n(DST ends)",
        "2015-10-04" = "2015-10-04\n(DST begins)"
      )
    )
  ) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_rect(
    aes(xmin = xmin, xmax = xmax),
    ymin = -Inf,
    ymax = Inf,
    fill = "grey20",
    alpha = 0.2,
    data = data.frame(
      Date_Time = as.POSIXct(NA),
      Count = Inf,
      xmin = as.POSIXct(
        c("2015-04-05 02:00", "2015-10-04 02:00"),
        tz = "UTC"
      ),
      xmax = as.POSIXct(
        c("2015-04-05 03:00", "2015-10-04 04:00"),
        tz = "UTC"
      ),
      Date = as.Date(c("2015-04-05", "2015-10-04"))
    )
  ) + 
  labs(x = "Civil time (Australia/Melbourne)")
```

If you want to see the absolute time values instead, you can use `position_time_absolute()`.
```{r}
#| label: dst-absolute
pedestrian |>
  filter(
    Sensor == "Southern Cross Station",
    Date %in% as.Date(c("2015-04-05", "2015-10-04"))
  ) |>
  ggplot(aes(x = Date_Time, y = Count)) +
  geom_time_line(position = position_time_absolute()) +
  geom_point(position = position_time_absolute()) +
  facet_grid(
    cols = vars(Date),
    scales = "free_x",
    labeller = labeller(
      Date = c(
        "2015-04-05" = "2015-04-05\n(DST ends)",
        "2015-10-04" = "2015-10-04\n(DST begins)"
      )
    )
  ) +
  scale_x_datetime(date_labels = "%H:%M") + 
  labs(x = "Absolute time (Australia/Melbourne)")
```

<!-- Daily -->

Differences in timezones are also relevant for precisely positioning daily data. Consider pedestrian counts in Melbourne (timezone Australia/Melbourne) and in London (timezone Europe/London). The data is collected over the same dates, but the local time of day is different due to the timezone difference. The ggtime package positions dates in civil time by default (matching ggplot2), but the relative position of dates in different timezones can be shown with `position_time_absolute()`.

Note: storing timezone information with dates requires the mixtime package, which is currently in development. The example below uses a helper function `force_tzs()` to add timezone information to `Date` dates for demonstration purposes.

```{r}
#| label: pedestrian-mel-lon
#| fig-height: 6
#| code-fold: true
MEL_LDN_mockdata <- pedestrian |>
  filter(
    between(Date, ymd("2015-03-05"), ymd("2015-03-11")),
    Sensor %in% c("Bourke Street Mall (North)", "QV Market-Elizabeth St (West)")
  ) |>
  index_by(Date) |>
  group_by(Sensor) |>
  summarise(Count = sum(Count)) |>
  as_tibble() |>
  mutate(
    Sensor = factor(
      Sensor,
      levels = c("Bourke Street Mall (North)", "QV Market-Elizabeth St (West)"),
      labels = c("Melbourne", "London")
    ),
    Count = case_when(Sensor == "London" ~ Count * 1.75, TRUE ~ Count),
    Date = as.POSIXct(Date, tz = "UTC")
  ) |>
  as_tsibble(index = Date, key = Sensor, regular = FALSE)
daily_civil <- MEL_LDN_mockdata |>
  ggplot(aes(x = Date, y = Count, colour = Sensor, shape = Sensor)) +
  geom_line() +
  geom_point(size = 3) +
  labs(x = "Civil time")
daily_absolute <- MEL_LDN_mockdata |>
  mutate(
    Date = force_tzs(
      Date,
      tzones = case_match(
        Sensor,
        "Melbourne" ~ "Australia/Melbourne",
        "London" ~ "Europe/London"
      )
    )
  ) |>
  ggplot(aes(x = Date, y = Count, colour = Sensor, shape = Sensor)) +
  geom_line() +
  geom_point(size = 3) +
  labs(x = "Absolute time (UTC)")


((daily_civil + guides(colour = "none", shape = "none")) / daily_absolute) &
  plot_layout(guides = "collect", axes = "collect") &
  scale_x_datetime(date_breaks = "1 day", date_labels = "%b %d") &
  geom_vline(
    xintercept = as.POSIXct("2015-03-08", tz = "UTC"),
    linetype = "dashed"
  ) &
  labs(y = NULL) &
  theme(legend.position = "bottom")
```

<!-- TODO: Why aren't the x-axis scales aligned in patchwork? -->

## Cyclical time looping

![](chi26-figures/fig-wishlist-01.jpg)

Presented separately for you to experiment with layouts.

**Sawtooth**

```{r}
#| label: discrete-cycle-sawtooth
uad |> 
  ggplot(aes(x = month(index), y = value)) +
  geom_line() +
  geom_point(aes(colour = year(index))) +
  labs(x = "Month", y = "Deaths", colour = "Year")
```


**Loop w/ missing data Dec/Jan**

(using discretised cyclical time month of year)

```{r}
#| label: coord-loop-cartesian-missing
uad |> 
  ggplot(aes(x = month(index, label = TRUE), y = value, group = year(index))) +
  geom_line() +
  geom_point(aes(colour = year(index)), size = 2) +
  geom_vline(
    xintercept = c(1, 12),
    linetype = "dashed",
    colour = "grey50"
  ) +
  labs(x = "Month", y = "Deaths", colour = "Year")
```

**Loop w/ overlapping Dec/Jan (polar)**

(using integer cyclical time month of year)

```{r}
#| label: coord-loop-polar-overlap
as_tsibble(USAccDeaths) |>
  ggplot(aes(x = month(index), y = value, group = year(index))) +
  geom_line() +
  geom_point(aes(colour = year(index)), size = 2) +
  geom_vline(
    xintercept = c(1, 12),
    linetype = "dashed",
    colour = "grey50"
  ) +
  coord_polar() +
  labs(x = "Month", y = "Deaths", colour = "Year") 
```

**Loop w/ missing data Dec/Jan (polar)**

(using discretised cyclical time month of year)

```{r}
#| label: coord-loop-polar-missing
as_tsibble(USAccDeaths) |>
  ggplot(aes(x = month(index, label = TRUE), y = value, group = year(index))) +
  geom_line() +
  geom_point(aes(colour = year(index)), size = 2) +
  geom_vline(
    xintercept = c(1, 12),
    linetype = "dashed",
    colour = "grey50"
  ) +
  coord_polar() +
  labs(x = "Month", y = "Deaths") 
```

**Loop in ggtime with coord_loop()**

```{r}
#| label: coord-loop-ggtime-cartesian
uad |> 
  ggplot(aes(x=index, y=value)) +
  geom_line() +
  geom_point(aes(colour = year(index)), size = 2) +
  geom_vline(
    xintercept = as.Date(c(1, 365-30)),
    linetype = "dashed",
    colour = "grey50"
  ) +
  coord_loop(time_loop = "1 year", expand = FALSE, ljust = 14)
```

**Loop in ggtime with coord_loop(polar = TRUE)**

WIP awaiting mjskay to extend coord_loop() to clip polar projected rectangles.

```{r}
#| label: coord-loop-ggtime-polar
#| eval: false
as_tsibble(USAccDeaths) |>
  ggplot(aes(x = index, y = value)) +
  geom_line() +
  geom_point(aes(colour = year(index)), size = 2) +
  coord_loop(time_loop = "1 year", polar = TRUE) +
  labs(x = "Month", y = "Deaths") 
```

Work-around alternative using ggplot2 and carefully selected scale/coord limits.

```{r}
#| label: coord-loop-polar
#| code-fold: true
month0 = min(uad$index)
uad |>
  ggplot(aes(x = index, y = value)) +
  geom_line() +
  geom_vline(
    xintercept = as.Date(c(1, 365-30)),
    linetype = "dashed",
    colour = "grey50"
  ) +
  coord_polar() +
  labs(x = "Month", y = "Deaths") +
  scale_x_date(
    limits = month0 + months(c(0, 12)),
    oob = scales::oob_keep,
    breaks = month0 + months(0:11),
    date_labels = "%b"
  )
```

Or alternatively with `coord_radial()` and coord limits...

```{r}
#| label: coord-loop-radial
uad |>
  ggplot(aes(x = index, y = value)) +
  geom_line() +
  coord_radial(thetalim = month0 + c(0, 332)) +
  labs(x = "Month", y = "Deaths") +
  geom_vline(
    xintercept = as.Date(c(1, 365 - 30)),
    linetype = "dashed",
    colour = "grey50"
  ) +
  scale_x_date(
    breaks = month0 + months(0:11),
    date_labels = "%b"
  )
```

## Unordered discretisation of cyclical time

![](chi26-figures/fig-wishlist-02a.jpg)

When discretising cyclical time to text using `strftime()`, e.g. "2025-08-18" to "Aug", the resulting text is not ordered (unless using lubridate which uses ordered factors, which has a lesser issue of not preserving temporal mass).

```{r}
#| label: unordered-discrete-cycle
chr_order_facet <- uad |> 
  ggplot(aes(x = as.Date(index), y = value)) +
  geom_line() +
  labs(x = NULL, y = "Deaths") +
  facet_grid(cols = vars(strftime(index, format = "%b"))) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
chr_order_cartesian <- as_tsibble(USAccDeaths) |>
  ggplot(aes(x = strftime(index, format = "%b"), y = value, group = year(index))) +
  geom_line() +
  labs(x = "Month", y = "Deaths") 
chr_order_polar <- as_tsibble(USAccDeaths) |>
  ggplot(aes(x = strftime(index, format = "%b"), y = value, group = year(index))) +
  geom_line() +
  coord_polar() +
  labs(x = "Month", y = "Deaths") 

chr_order_facet / (chr_order_cartesian | chr_order_polar)
```

**Suggested alternative layouts**

```{r}
#| label: ordered-discrete-cycle
fct_order_facet <- uad |> 
  ggplot(aes(x = as.Date(index), y = value)) +
  geom_line() +
  labs(x = NULL, y = "Deaths") +
  facet_grid(cols = vars(month(index, label = TRUE))) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

fct_order_cartesian <- as_tsibble(USAccDeaths) |>
  ggplot(aes(x = month(index, label = TRUE), y = value, group = year(index))) +
  geom_line() +
  labs(x = "Month", y = "Deaths") 

fct_order_polar <- as_tsibble(USAccDeaths) |>
  ggplot(aes(x = month(index, label = TRUE), y = value, group = year(index))) +
  geom_line() +
  coord_polar() +
  labs(x = "Month", y = "Deaths") 
```

```{r}
#| label: ordered-discrete-facet-layout
(fct_order_facet / chr_order_facet) & plot_layout(guides = "collect", axes = "collect")
```

```{r}
#| label: ordered-discrete-cartesian-layout
wrap_plots(fct_order_cartesian, chr_order_cartesian, nrow = 2, axes = "collect")
```

```{r}
#| label: ordered-discrete-polar-layout
wrap_plots(fct_order_polar, chr_order_polar, ncol = 2, axes = "collect") & labs(x = NULL)
```

```{r}
#| label: ordered-discrete-combined-layout
#| fig-height: 6
wrap_plots(
  A = fct_order_facet / chr_order_facet,
  B = fct_order_cartesian, C = chr_order_cartesian,
  D = fct_order_polar, E = chr_order_polar,
  ncol = 2, nrow = 3,
  widths = c(3, 1), heights = c(1.5, 1, 1),
  design = "AA\nBD\nCE"
) & labs(y = NULL, x = NULL)

```

## Implicit missing values

![](chi26-figures/fig-wishlist-02b.jpg)

```{r}
#| label: implicit-missing
implicit_na_before <- bank_calls |> 
  filter(DateTime < ymd_hms("2003-03-15 00:00:00")) |>
  ggplot(aes(x = DateTime, y = Calls)) +
  geom_line() + 
  labs(title = "ggplot2")

implicit_na_after <- bank_calls |> 
  filter(DateTime < ymd_hms("2003-03-15 00:00:00")) |>
  fill_gaps() |> 
  ggplot(aes(x = DateTime, y = Calls)) +
  geom_line() + 
  labs(title = "ggtime")

wrap_plots(implicit_na_before, implicit_na_after, ncol = 2, axes = "collect") + 
  plot_annotation(title = "Implicit missing time values")
```

## ggtime <3 ggdist

ggtime is designed to work well with other extension packages, especially those that enable plotting of other semantic variables such as ggdist for visualising distributions.

```{r}
#| label: ggtime-ggdist-pedestrian
#| message: false
library(fable)
ped_train <- pedestrian |> 
  filter(
    Sensor == "Southern Cross Station",
    Date > ymd("2015-01-30") &
    Date < ymd("2015-04-21")
  ) |> 
    index_by(Date) |>
    summarise(Count = sum(Count))
ped_train |> 
  model(
    ets = ETS(Count)
  ) |> 
  forecast(h = "4 weeks") |>
  autoplot(ped_train)
```

```{r}
#| label: ggtime-ggdist-uad
#| message: false
library(fable)
library(ggplot2)
uad <- as_tsibble(USAccDeaths)
uad |> 
  model(ARIMA(value)) |>
  forecast(h = "2 years") |>
  autoplot(uad) +
  labs(
    title = "Forecast of US accidental deaths",
    y = "Number of deaths",
    x = "Year"
  ) + 
  theme(legend.position = c(0.06,0.9))
```

```{r}
#| label: ggtime-ggdist-minimal
library(ggplot2)
ggplot(data = data.frame(
  time = mixtime::yearmonth(Sys.Date()) + 0:3, 
  dist = distributional::dist_normal(mean = c(1,5,3,7), sd = 1:4
))) + 
  ggdist::stat_lineribbon(aes(x = time, ydist = dist)) + 
  scale_fill_brewer()
```

## Temporal resolution / aggregation

![](chi26-figures/fig-wishlist-03.jpg)


<!-- ### Continuous time -->
<!-- * Continuous visualisation with different resolutions -->

Code creating *continuous* time series plots with different temporal aggregations.

```{r}
#| label: continuous-time-resolution
#| message: false
res_30m_cont <- vic_elec |> 
  ggplot(aes(x = Time, y = Demand)) + 
  geom_line() + 
  labs(x = "Time", y = "Demand (MW)")
res_1d_cont <- vic_elec |> 
  index_by(Date) |>
  summarise(Demand = sum(Demand)) |>
  ggplot(aes(x = Date, y = Demand)) + 
  geom_line() + 
  labs(x = "Time", y = "Demand (MW)")
res_1w_cont_bad <- vic_elec |> 
  index_by(Week = yearweek(Time)) |>
  summarise(Demand = sum(Demand)) |>
  ggplot(aes(x = Week, y = Demand)) + 
  geom_line() + 
  labs(x = "Time", y = "Demand (MW)")
res_1w_cont <- vic_elec |> 
  index_by(Week = yearweek(Time)) |>
  summarise(Demand = sum(Demand)) |>
  # Removing incomplete aggregation weeks by row.
  slice(-1, -n()) |>
  ggplot(aes(x = Week, y = Demand)) + 
  geom_line() + 
  labs(x = "Time", y = "Demand (MW)")
```

<!-- ### Cyclical time -->
<!-- * Cyclical/Seasonal visualisation with different resolutions -->

Code creating *cyclical* time series plots with different temporal aggregations.

```{r}
#| label: cyclical-time-resolution
#| message: false
res_30m_loop_1y <- vic_elec |> 
  gg_season(period = "year")
res_1d_loop_1y <- vic_elec |> 
  index_by(Date) |>
  summarise(Demand = sum(Demand)) |>
  gg_season(period = "year")
res_1w_loop_1y <- vic_elec |> 
  index_by(Week = yearweek(Time)) |>
  summarise(Demand = sum(Demand)) |>
  # Removing incomplete aggregation weeks by row
  slice(-1, -n()) |> 
  gg_season(period = "year")
res_30m_loop_1w <- vic_elec |> 
  gg_season(period = "week")
res_1d_loop_1w <- vic_elec |> 
  index_by(Date = date(Time)) |>
  summarise(Demand = sum(Demand)) |>
  gg_season(period = "week")
```

**Plots arranged to match drawing**

TODO: Rework with ggtime exclusively, to demonstrate its functionality for ETSA.

```{r}
#| label: resolution-drawn-layout
((
  (res_30m_cont + geom_vline(xintercept = make_date(2012:2015, 1, 1), linetype = "dashed", color = "gray50")) / 
  res_1w_cont_bad
) | 
(
  res_30m_loop_1y /
  (res_1d_loop_1w + annotate("rect", xmin = as.Date("1973-01-06"), xmax = as.Date("1973-01-08"), ymin = -Inf, ymax = Inf, fill = "grey80", alpha = 0.3))
) & guides(colour = "none"))

```

**Alternative(s)**

```{r}
#| label: resolution-alternative-layout
(res_30m_cont / res_1d_cont / res_1w_cont) |
(res_30m_loop_1y / res_1d_loop_1y / res_1w_loop_1y) & guides(colour = "none")
```

## Granularity alignment (NYT)

![](chi26-figures/fig-wishlist-04.jpg)

```{r}
#| label: nyt-floyd
#| code-fold: true
#| message: false
#| fig-width: 12
#| fig-height: 6
library(ggplot2)
library(dplyr)

col_homicide <- "#FB8C58"
col_police_killings <- "#980000"

nyt_floyd_plot_common <- function(p, xoffset = 0) {
  p +   
  # Add vertical line for George Floyd's death (assuming 2020)
  geom_vline(xintercept = 2020.3686, linetype = "dashed", color = "gray60", linewidth = 0.8) +
  
  # Custom colors to match the reference
  scale_color_manual(values = c("Homicides" = col_homicide, "Police killings" = col_police_killings)) +
  
  # Format y-axis as years
  scale_x_continuous(
    breaks = 2015:2024 + xoffset, labels = \(x) scales::number(floor(x)),
    expand = c(0, 0.2)
  ) +

  # Format y-axis as percentages
  scale_y_continuous(
    breaks = seq(-10, 50, 10), labels = scales::label_percent(scale = 1),
    limits = c(-10, 50), expand = c(0, 0)
  ) +

  # Customize theme
  theme_minimal() +
  theme(
    # Remove legend
    legend.position = "none",
    
    # Grid lines
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_line(color = "gray90", size = 0.5),
    
    # Axis styling
    axis.line.x = element_line(color = "black", size = 0.8),
    axis.text = element_text(color = "gray30", size = 10),
    axis.title = element_blank(),
    axis.ticks.x = element_line(color = "gray30"),
    axis.ticks.y = element_blank(),
    
    # Plot styling
    plot.title = element_text(size = 16, face = "bold", margin = margin(b = 5)),
    plot.subtitle = element_text(size = 12, color = "gray50", margin = margin(b = 20)),
    plot.caption = element_text(size = 9, color = "gray50", hjust = 0, margin = margin(t = 20)),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  ) +
  
  # Add labels
  labs(
    title = "Police killings continued to rise as other homicides fell",
    subtitle = "Percent change in homicides and police killings since 2015",
    caption = "Sources: Analysis of data compiled by The Washington Post and Mapping Police Violence. Homicide data from the\nCenters for Disease Control and Prevention. â€” The New York Times"
  ) +
  
  # Add direct labels for the lines (you may need to adjust positions based on your data)
  annotate(
    "text", x = 2022.3 + xoffset, y = 39, label = "Homicides", 
    color = col_homicide, size = 4, hjust = 0, fontface = "bold"
  ) +
  
  annotate(
    "text", x = 2022.3 + xoffset, y = 6, label = "Police killings", 
    color = col_police_killings, size = 4, hjust = 0, fontface = "bold"
  ) +
  
  # Add annotation for George Floyd's death
  annotate(
    "label", x = 2020.3686, y = 50-xoffset*10, label = "Death of\nGeorge Floyd\nMay 25, 2020", 
     hjust = 0.5, vjust = 0.3, size = 4, color = "gray30", fill = "white", border.colour = "white"
  ) +

  # Add shaded region for the year 2020
  annotate("rect", xmin = 2020, xmax = 2021, 
           ymin = -Inf, ymax = Inf, fill = "grey80", alpha = 0.3) +

  # Expand x-axis to make room for labels
  coord_cartesian(clip = "off")
}

p1 <- (readr::read_csv("chi26-figures/nyt-floyd.csv") |> 
  ggplot(aes(x = year, y = percent_change, colour = type)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2.5)) |> 
  nyt_floyd_plot_common()
p1

p2 <- (readr::read_csv("chi26-figures/nyt-floyd.csv") |> 
  ggplot(aes(x = year, y = percent_change, colour = type)) +
  geom_step(linewidth = 1.2)) |> 
  nyt_floyd_plot_common()
p2

p3 <- (readr::read_csv("chi26-figures/nyt-floyd.csv") |> 
  ggplot(aes(x = year + 0.5, y = percent_change, colour = type)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2.5)) |> 
  nyt_floyd_plot_common(xoffset = 0.5)
p3
```

```{r}
#| label: nyt-floyd-layout
#| fig-width: 12
#| fig-height: 6
#| message: false
library(patchwork)
((p1/p3)|p2) & scale_x_continuous(limits = c(2015, 2024.5), breaks = seq(2015, 2024, 1.5), labels = scales::label_number()) & labs(title = NULL, subtitle = NULL, caption = NULL)
```

## Looping and warping (ragged and justified)

![](chi26-figures/fig-wishlist-05.jpg)

Stretch goal, requires:

* `coord_loop()` to support specific loop points (`loop` not just `time_loop`).
* `scale_*_mixtime()` to support warp points (`warp` and `time_warp`).

```{r}
#| label: find-peaks
#| code-fold: true

#' Find peaks in time series data
#'
#' @param x Numeric vector of time series values
#' @param min_distance Minimum distance between peaks (default: 1)
#' @param threshold Minimum height threshold for peaks (default: 0)
#' @return Integer vector of peak indices
#' @export
find_peaks <- function(x, min_distance = 1, threshold = 0) {
  n <- length(x)
  if (n < 3) return(integer(0))
  
  # Find local maxima
  peaks <- integer(0)
  for (i in 2:(n-1)) {
    if (x[i] > x[i-1] && x[i] > x[i+1] && x[i] > threshold) {
      peaks <- c(peaks, i)
    }
  }
  
  # Apply distance constraint
  if (length(peaks) > 1 && min_distance > 1) {
    keep <- c(TRUE, diff(peaks) >= min_distance)
    peaks <- peaks[keep]
  }
  
  peaks
}
```

Locations of automatically detected peaks in the lynx data:

```{r}
#| label: lynx-peaks
tsibbledata::pelt |> 
  ggplot(aes(x = Year, y = Lynx)) + 
  geom_line() + 
  geom_point(size = 3, colour = "red", 
             data = tsibbledata::pelt |> slice(find_peaks(Lynx))) +
  labs(x = "Time", y = "Lynx trapped")
```

Hypothetical `coord_loop()` looping at these peak points:

```{r}
#| label: lynx-peaks-loop
tsibbledata::pelt |> 
  ggplot(aes(x = Year, y = Lynx)) + 
  geom_line() + 
  geom_point(size = 3, colour = "red", 
             data = slice(tsibbledata::pelt, find_peaks(Lynx))) +
  coord_loop(loop = slice(tsibbledata::pelt, find_peaks(Lynx))$Year)
```


```{r}
#| label: ragged-justified
month_progress <- unlist(lapply(lubridate:::N_DAYS_IN_MONTHS[seq_len(3)], \(x) seq(1, x)/x))

time <- make_date(year = 2025) + 0:89
# y <- rnorm(length(month_progress), mean = month_progress^4, sd = month_progress*0.1)
y <- sin(month_progress*2*pi) + rnorm(length(time), sd = 0.1)


tbl_ragged <- tibble(time, y, month_progress)
plt_ragged <- tbl_ragged |> 
  ggplot(aes(x = time - floor_date(time, "month"), y = y, group = month(time))) + 
  geom_line() +
  geom_point(
    data = tbl_ragged |> group_by(yearmonth(time)) |> filter(time %in% range(time)),
    size = 3
  ) + 
  labs(x = "Day of month")

time <- make_date(year = 2025) + 0:89
# y <- rnorm(length(month_progress), mean = month_progress^4, sd = month_progress*0.1)
y <- sin(month_progress*2*pi) + rnorm(90, sd = 0.1)

tbl_justified <- tibble(time, y, month_progress)
plt_justified <- tbl_justified |> 
  ggplot(aes(x = month_progress, y = y, group = month(time))) + 
  scale_x_continuous(labels = scales::percent) +
  geom_line() +
  geom_point(
    data = tbl_justified|> group_by(yearmonth(time)) |> filter(time %in% range(time)), 
    size = 3
  ) +
    labs(x = "Percentage of month")
  

((plt_ragged + guides(colour = "none")) / plt_justified) & aes(colour = month(time, label = TRUE)) & plot_layout(guides = "collect", axes = "collect") & theme(legend.position = "bottom") & labs(colour = "Month", y = NULL)
((plt_ragged + 
  facet_grid(rows = vars(month(time, label = TRUE)))) |
(plt_justified +
  facet_grid(rows = vars(month(time, label = TRUE))))) & aes(colour = month(time, label = TRUE))

wrap_plots(
  plt_ragged + facet_grid(rows = vars(month(time, label = TRUE))),
  plt_justified + facet_grid(rows = vars(month(time, label = TRUE))),
  ncol = 2, guides = "collect", axes = "collect"
) & labs(y = NULL)
```


